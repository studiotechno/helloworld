// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Users table - stores authenticated users from GitHub OAuth
model users {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  github_id    String   @unique
  email        String?
  name         String?
  avatar_url   String?
  github_token String?  // Stored encrypted via Supabase Vault
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  updated_at   DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  repositories  repositories[]
  conversations conversations[]
  instructions  user_instructions?
  token_usage   token_usage[]

  @@map("users")
}

// Token Usage table - tracks API token consumption for billing
model token_usage {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  type          String   // 'chat' | 'indexing_context' | 'indexing_embedding'
  model         String   // 'haiku' | 'sonnet' | 'devstral' | 'voyage-code-3'
  input_tokens  Int
  output_tokens Int      @default(0)
  created_at    DateTime @default(now()) @db.Timestamptz(6)

  // Relations
  user users @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([created_at])
  @@index([user_id, type], map: "idx_token_usage_user_type")
  @@index([user_id, model], map: "idx_token_usage_user_model")
  @@map("token_usage")
}

// User Instructions table - stores personalized context for AI responses
model user_instructions {
  id                   String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id              String   @unique @db.Uuid
  profile_instructions String?  @db.Text // Who the user is (PM, tech level, preferences)
  team_instructions    String?  @db.Text // Team structure, workflow, methodology
  created_at           DateTime @default(now()) @db.Timestamptz(6)
  updated_at           DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  user users @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_instructions")
}

// Repositories table - stores connected GitHub repositories
model repositories {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String    @db.Uuid
  github_repo_id String
  full_name      String    // owner/repo format
  default_branch String    @default("main")
  is_active      Boolean   @default(true)
  last_synced_at DateTime? @db.Timestamptz(6)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)

  // Relations
  user          users          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  conversations conversations[]
  code_chunks   code_chunks[]
  indexing_job  indexing_jobs?

  @@unique([user_id, github_repo_id])
  @@map("repositories")
}

// Code Chunks table - stores indexed code with embeddings for RAG
model code_chunks {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  repository_id String   @db.Uuid

  // Localisation
  file_path  String
  start_line Int
  end_line   Int

  // Contenu
  content    String @db.Text
  language   String // typescript, python, go, etc.
  chunk_type String // function, class, interface, config, other

  // Metadata pour ameliorer le retrieval
  symbol_name  String?  // Nom de la fonction/classe
  dependencies String[] @default([]) // Imports detectes
  context      String?  @db.Text // Contextual description from LLM (for Contextual Retrieval)

  // Note: embedding column is added via raw SQL migration (pgvector)
  // ALTER TABLE code_chunks ADD COLUMN embedding vector(1024);

  // Note: search_vector column is added via raw SQL migration (tsvector for full-text search)
  // ALTER TABLE code_chunks ADD COLUMN search_vector tsvector;
  // A trigger automatically updates this column on insert/update

  // Tracking
  file_hash  String   // SHA256 du fichier pour detecter changements
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // Relations
  repository repositories @relation(fields: [repository_id], references: [id], onDelete: Cascade)

  @@index([repository_id])
  @@index([file_path])
  @@index([chunk_type])
  @@map("code_chunks")
}

// Indexing Jobs table - tracks code indexation progress
model indexing_jobs {
  id            String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  repository_id String @unique @db.Uuid

  status   String @default("pending") // pending, fetching, parsing, embedding, completed, failed
  progress Int    @default(0) // 0-100

  files_total     Int @default(0)
  files_processed Int @default(0)
  chunks_created  Int @default(0)

  current_phase String? // "Fetching files", "Parsing code", "Generating embeddings"
  error_message String? @db.Text

  // Commit tracking for detecting updates
  last_indexed_commit_sha String? // SHA of the commit when indexation completed

  started_at   DateTime? @db.Timestamptz(6)
  completed_at DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  // Relations
  repository repositories @relation(fields: [repository_id], references: [id], onDelete: Cascade)

  @@map("indexing_jobs")
}

// Conversations table - stores chat conversations
model conversations {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @db.Uuid
  repository_id String   @db.Uuid
  title         String?  // Auto-generated from first message
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  updated_at    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  user       users        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  repository repositories @relation(fields: [repository_id], references: [id], onDelete: Cascade)
  messages   messages[]

  @@map("conversations")
}

// Messages table - stores chat messages
model messages {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversation_id String   @db.Uuid
  role            String   // 'user' or 'assistant'
  content         String
  citations       Json     @default("[]") // [{file, line, snippet}]
  created_at      DateTime @default(now()) @db.Timestamptz(6)

  // Relations
  conversation conversations @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  @@map("messages")
}
